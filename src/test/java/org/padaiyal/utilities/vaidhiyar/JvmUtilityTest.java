package org.padaiyal.utilities.vaidhiyar;

import com.sun.management.OperatingSystemMXBean;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.time.Duration;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Future;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.mockito.ArgumentMatchers;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.padaiyal.utilities.I18nUtility;
import org.padaiyal.utilities.PropertyUtility;
import org.padaiyal.utilities.vaidhiyar.abstractions.CpuLoadGenerator;
import org.padaiyal.utilities.vaidhiyar.abstractions.ExtendedThreadInfo;

/**
 * Tests JvmUtility.
 */
public final class JvmUtilityTest {

  /**
   * Logger object used to log information and errors.
   */
  private static final Logger logger = LogManager.getLogger(JvmUtilityTest.class);
  /**
   * Duration to wait for the CPU load generator to start generating the load.
   */
  private static long durationToWaitForCpuLoadGeneratorInMilliSeconds;
  /**
   * OperatingSystemMxBean object used to get the number of CPU cores in this system.
   */
  private static OperatingSystemMXBean operatingSystemMxBean;
  /**
   * Duration over which the CPU thread times have been sampled. (Test value)
   */
  private static Long samplingDurationInMilliSeconds;
  /**
   * Initial thread CPU times. (Test values)
   */
  private static Map<Long, Long> initialThreadCpuTimesInNanoSeconds;
  /**
   * Current thread CPU times. (Test values)
   */
  private static Map<Long, Long> currentThreadCpuTimesInNanoSeconds;
  /**
   * Stores the computed thread CPU usages.
   */
  private static Map<Long, Double> threadCpuUsages;

  /**
   * Sets up dependant values needed for the test.
   *
   * @throws IOException When there is an issue adding the property file.
   */
  @BeforeAll
  public static void setUp() throws IOException {
    PropertyUtility.addPropertyFile(
        JvmUtilityTest.class,
        "JvmUtilityTest.properties"
    );
    durationToWaitForCpuLoadGeneratorInMilliSeconds = PropertyUtility.getTypedProperty(
        Long.class,
        "JvmUtilityTest.durationToWaitForCpuLoadGenerator.milliseconds"
    );

    I18nUtility.addResourceBundle(
        JvmUtilityTest.class,
        JvmUtilityTest.class.getSimpleName(),
        Locale.US
    );

    operatingSystemMxBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
    samplingDurationInMilliSeconds = 1L;
    initialThreadCpuTimesInNanoSeconds = new HashMap<>();
    initialThreadCpuTimesInNanoSeconds.put(996L, 112_000L);
    initialThreadCpuTimesInNanoSeconds.put(997L, 34_000L);
    initialThreadCpuTimesInNanoSeconds.put(998L, 232_000L);

    currentThreadCpuTimesInNanoSeconds = new HashMap<>();
    currentThreadCpuTimesInNanoSeconds.put(997L, 112_000L);
    currentThreadCpuTimesInNanoSeconds.put(998L, 580_000L);
    currentThreadCpuTimesInNanoSeconds.put(999L, 930_000L);

    // Valid values
    threadCpuUsages = JvmUtility.getThreadCpuUsages(
        initialThreadCpuTimesInNanoSeconds,
        currentThreadCpuTimesInNanoSeconds,
        samplingDurationInMilliSeconds
    );
  }

  /**
   * Tests JvmUtility::getAllExtendedThreadInfo().
   */
  @Test
  public void testExtendedThreadInfo() {
    Arrays.stream(JvmUtility.getAllExtendedThreadInfo())
        .forEach(extendedThreadInfo -> {
          Assertions.assertTrue(extendedThreadInfo.getCpuUsage() >= -1);
          Assertions.assertTrue(extendedThreadInfo.getCpuUsage() <= 100);
          Assertions.assertTrue(extendedThreadInfo.getMemoryAllocatedInBytes() >= 0);
          Assertions.assertNotNull(extendedThreadInfo.getThreadInfo());
        });
  }

  /**
   * Tests JvmUtility::getAllExtendedThreadInfo() for the CPU usage aspect.
   *
   * @param testDurationInMilliSeconds    Duration for which the CPU load has to be generated.
   * @param expectedCpuLoad               CPU load to be generated by the CPU load generator.
   * @param actualCpuLoadAllowedTolerance Allowed % tolerance in actual load thread CPU usage value.
   * @throws InterruptedException         When the thread sleep is interrupted.
   * @throws IOException                  When there is an issue instantiating the CPULoadGenerator
   *                                      object.
   */
  @ParameterizedTest
  @CsvSource({
      "60000, 0.6, 0.5"
  })
  public void testThreadCpuUsage(
      long testDurationInMilliSeconds,
      double expectedCpuLoad,
      double actualCpuLoadAllowedTolerance
  ) throws InterruptedException, IOException {
    final CpuLoadGenerator cpuLoadGenerator = new CpuLoadGenerator();
    cpuLoadGenerator.start(expectedCpuLoad, testDurationInMilliSeconds);

    String expectedCpuLoadThreadName = PropertyUtility.getProperty("CpuLoadGenerator.thread.name");

    Arrays.stream(JvmUtility.getAllExtendedThreadInfo())
        .filter(extendedThreadInfo -> extendedThreadInfo.getThreadInfo()
            .getThreadName()
            .equals(expectedCpuLoadThreadName)
        )
        .map(extendedThreadInfo -> extendedThreadInfo.getCpuUsage() == -1)
        .forEach(Assertions::assertTrue);

    // Wait for the CPU load generator to start.
    Thread.sleep(durationToWaitForCpuLoadGeneratorInMilliSeconds);
    ExtendedThreadInfo[] extendedThreadInfos = JvmUtility.getAllExtendedThreadInfo();

    Assertions.assertNotNull(extendedThreadInfos);

    Assertions.assertEquals(
        operatingSystemMxBean.getAvailableProcessors(),
        Arrays.stream(extendedThreadInfos)
            .filter(extendedThreadInfo -> extendedThreadInfo.getThreadInfo().getThreadName()
                .equals(expectedCpuLoadThreadName))
            .count()
    );

    // Test if required load is generated within an expected amount of time.
    Assertions.assertTimeoutPreemptively(
        Duration.ofMillis(testDurationInMilliSeconds),
        () -> {
          boolean requiredLoadGenerated = false;
          while (!requiredLoadGenerated) {
            requiredLoadGenerated = Arrays.stream(extendedThreadInfos)
                .filter(extendedThreadInfo -> extendedThreadInfo.getThreadInfo()
                    .getThreadName()
                    .equals(expectedCpuLoadThreadName)
                )
                .peek(
                    extendedThreadInfo -> logger.info(
                        I18nUtility.getFormattedString(
                          "JvmUtilityTest.printThreadCpuUsage",
                          extendedThreadInfo.getThreadInfo().getThreadName(),
                          extendedThreadInfo.getThreadInfo().getThreadId(),
                          extendedThreadInfo.getCpuUsage(),
                          expectedCpuLoad * (1.0 - actualCpuLoadAllowedTolerance)
                        )
                    )
                )
                .map(extendedThreadInfo -> (
                        extendedThreadInfo.getCpuUsage() / 100.0
                            >= expectedCpuLoad * (1.0 - actualCpuLoadAllowedTolerance)
                    )
                )
                .reduce(Boolean::logicalAnd)
                .orElse(false);
          }
        }
    );

  }

  /**
   * Tests starting/terminating the thread CPU usage collector.
   *
   * @throws InterruptedException If the thread sleep is interrupted.
   */
  @Test
  public void testCpuUsageCollector() throws InterruptedException {
    Assertions.assertTrue(JvmUtility.getRunThreadCpuUsageCollectorSwitch());
    Assertions.assertTrue(JvmUtility.isThreadCpuUsageCollectorRunning());

    JvmUtility.setRunThreadCpuUsageCollectorSwitch(false);
    Assertions.assertFalse(JvmUtility.getRunThreadCpuUsageCollectorSwitch());

    // Wait for CPU usage collector to terminate.
    Thread.sleep(durationToWaitForCpuLoadGeneratorInMilliSeconds);
    Assertions.assertFalse(JvmUtility.isThreadCpuUsageCollectorRunning());

    JvmUtility.setRunThreadCpuUsageCollectorSwitch(false);
    Assertions.assertFalse(JvmUtility.getRunThreadCpuUsageCollectorSwitch());

    JvmUtility.setRunThreadCpuUsageCollectorSwitch(true);

    Assertions.assertTrue(JvmUtility.getRunThreadCpuUsageCollectorSwitch());

    // Wait for CPU usage collector to start.
    Thread.sleep(durationToWaitForCpuLoadGeneratorInMilliSeconds);
    Assertions.assertTrue(JvmUtility.isThreadCpuUsageCollectorRunning());

    // Ensure that a new thread is not spawned when the runThreadCpuUsageCollector is set to true
    // again.
    Future<Void> initialFutureObject = JvmUtility.getCpuUsageCollectorFuture();
    JvmUtility.setRunThreadCpuUsageCollectorSwitch(true);
    Assertions.assertEquals(
        initialFutureObject,
        JvmUtility.getCpuUsageCollectorFuture()
    );
  }

  /**
   * Tests JvmUtility.cpuUsageCollectorThread when JvmUtility::runCpuUsageCollector() throws an
   * InterruptedException.
   */
  @Test
  void testRunCpuCollectorInterruptedException() {
    try (
        MockedStatic<JvmUtility> threadMock = Mockito.mockStatic(JvmUtility.class)
    ) {
      threadMock.when(
          JvmUtility::runCpuUsageCollector
      ).thenThrow(InterruptedException.class);

      Assertions.assertThrows(
          RuntimeException.class,
          JvmUtility.cpuUsageCollectorThread::call
      );
    }
  }

  /**
   * Tests thread CPU usage computation given invalid inputs - initial thread CPU times,
   * current thread CPU times and the sampling duration.
   */
  @Test
  void testGetThreadCpuUsages() {

    Map<Long, Long> initialThreadCpuTimesInNanoSecondsWithNullValues = new HashMap<>();
    initialThreadCpuTimesInNanoSecondsWithNullValues.put(998L, null);

    Map<Long, Long> currentThreadCpuTimesInNanoSecondsWithNullValues = new HashMap<>();
    currentThreadCpuTimesInNanoSecondsWithNullValues.put(998L, null);

    Map<Long, Long> initialThreadCpuTimesInNanoSecondsWithInitialTimeGreaterThanCurrentTime
        = new HashMap<>();
    initialThreadCpuTimesInNanoSecondsWithInitialTimeGreaterThanCurrentTime.put(998L, 800L);

    Map<Long, Long> currentThreadCpuTimesInNanoSecondsWithCurrentTimeLesserThanInitialTime
        = new HashMap<>();
    currentThreadCpuTimesInNanoSecondsWithCurrentTimeLesserThanInitialTime.put(998L, 600L);

    Map<Long, Long> initialThreadCpuTimesInNanoSecondsWithNegativeValues = new HashMap<>();
    initialThreadCpuTimesInNanoSecondsWithNegativeValues.put(998L, -100L);

    Map<Long, Long> currentThreadCpuTimesInNanoSecondsWithNegativeValues = new HashMap<>();
    currentThreadCpuTimesInNanoSecondsWithNegativeValues.put(998L, -800L);


    // Null inputs
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            null,
            currentThreadCpuTimesInNanoSeconds,
            samplingDurationInMilliSeconds
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSeconds,
            null,
            samplingDurationInMilliSeconds
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSeconds,
            currentThreadCpuTimesInNanoSeconds,
            null
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            null,
            null,
            samplingDurationInMilliSeconds
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSeconds,
            null,
            null
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            null,
            currentThreadCpuTimesInNanoSeconds,
            null
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            null,
            null,
            null
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSecondsWithNullValues,
            currentThreadCpuTimesInNanoSeconds,
            samplingDurationInMilliSeconds
        )
    );
    Assertions.assertThrows(
        NullPointerException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSeconds,
            currentThreadCpuTimesInNanoSecondsWithNullValues,
            samplingDurationInMilliSeconds
        )
    );

    // Invalid inputs
    // currentThreadTime < initialThreadTime
    Assertions.assertThrows(
        IllegalArgumentException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSecondsWithInitialTimeGreaterThanCurrentTime,
            currentThreadCpuTimesInNanoSecondsWithCurrentTimeLesserThanInitialTime,
            samplingDurationInMilliSeconds
        )
    );

    // initialThreadTime < 0
    Assertions.assertThrows(
        IllegalArgumentException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSecondsWithNegativeValues,
            currentThreadCpuTimesInNanoSeconds,
            samplingDurationInMilliSeconds
        )
    );

    // currentThreadTime < 0
    Assertions.assertThrows(
        IllegalArgumentException.class,
        () -> JvmUtility.getThreadCpuUsages(
            initialThreadCpuTimesInNanoSecondsWithInitialTimeGreaterThanCurrentTime,
            currentThreadCpuTimesInNanoSecondsWithNegativeValues,
            samplingDurationInMilliSeconds
        )
    );
  }

  /**
   * Tests thread CPU usage computation given valid inputs - initial thread CPU times,
   * current thread CPU times and the sampling duration.
   *
   * @param threadId          Thread ID for which the CPU usage has to be retrieved.
   * @param expectedCpuUsage  Expected CPU usage for the specified thread ID.
   */
  @ParameterizedTest
  @CsvSource({
      // Should return null as Thread 996 does not have a currentThreadCPUTime.
      "996,",
      // Should return null as Thread 996 does not have a initialThreadCPUTime.
      "999,",
      "997,7.8",
      "998,34.8",
  })
  void testGetThreadCpuUsagesWithValidInputs(long threadId, Double expectedCpuUsage) {
    Assertions.assertEquals(
        expectedCpuUsage,
        threadCpuUsages.get(threadId)
    );
  }

  /**
   * Tests initializing dependant values when an IOException is thrown while adding a property file.
   */
  @Test
  void testDependantValuesInitializer() {

    // Mock throwing IOException when adding the property file.
    try (
        MockedStatic<PropertyUtility> propertyUtilityMock = Mockito.mockStatic(
            PropertyUtility.class
        )
    ) {
      propertyUtilityMock.when(
          () -> PropertyUtility.addPropertyFile(
              ArgumentMatchers.any(),
              ArgumentMatchers.anyString()
          )
      ).thenThrow(IOException.class);

      Assertions.assertDoesNotThrow(JvmUtility.dependantValuesInitializer::run);
    }
  }

  /**
   * Tests JvmUtility::getCpuUsage() when an invalid thread ID is supplied.
   *
   * @param threadId Thread ID for which the CPu usage is to be retrieved.
   */
  @ParameterizedTest
  @CsvSource({
      "-100"
  })
  void testGetCpuUsageWithInvalidInput(long threadId) {
    Assertions.assertThrows(
        IllegalArgumentException.class,
        () -> JvmUtility.getCpuUsage(threadId)
    );
  }

  /**
   * Tests JvmUtility::getAllocatedMemoryInBytes() when an invalid thread ID is supplied.
   *
   * @param threadId Thread ID for which the allocated memory size is to be retrieved.
   */
  @ParameterizedTest
  @CsvSource({
      "-100"
  })
  void testGetAllocatedMemoryInBytesWithInvalidInput(long threadId) {
    Assertions.assertThrows(
        IllegalArgumentException.class,
        () -> JvmUtility.getAllocatedMemoryInBytes(threadId)
    );
  }
}
